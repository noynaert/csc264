# 07.030 `puts`


## The `call` instruction

The `call` method calls functions

## How x86-64 assembler calls functions

I have added information about calling library functions to the ]Exam 02 cheat sheet](https://github.com/noynaert/csc264/blob/main/videoNotes/ex02Cheatsheet/cheatsheetExam02.pdf)

In x86-64, arguments are passed in registers and on the stack.  (These only apply to integers and addresses.  Floating point are different.)

- `rdi` for the first argument
- `rsi` for the second argument
- `rdi` for the third argument
- `rdx` for the fourth argument
- `rcx` for the fifth argument
- `r8`   for the sixth argument
- `r9`   for the seventh argument
- If there are more, they are put on the stack.

Called functions ***may*** change the following registers: rax, rcx, rdx, rsi, rdi, r8, r9, r10, and r11.  Note that r10 and r11 are the two registers not on the calling list.

# Calling `puts`

The first step is to visualize what the call would look like in C.  It would look like this:

```
char * message = "Hola";
puts(message);
```

Puts has only one argument, so we only need the `rdi` register.

It requires the ***address*** of the message.   This is represented as `$message`.  We need the leading $ because we are loading the address where the message is stored, not the 'H'.

```
/*
     Demonstrates use of puts

     File: prog.s
     assemble and link with gcc
*/

.globl main

.data
   message: .asciz "Hola."

.text
main:
  movq  $message, %rdi          # Address of message into %rdi
  call  puts                    # puts(message)
  movq  %rax, %r15               # save the return value  

_exit:
  movq $60, %rax
  movq %r15, %rdi
  syscall
```